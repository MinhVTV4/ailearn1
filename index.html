<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI H·ªçc T·∫≠p T∆∞∆°ng T√°c (v2)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root {
            --scrollbar-track-bg: #f1f1f1;
            --scrollbar-thumb-bg: #888;
            --scrollbar-thumb-hover-bg: #555;
        }
        .dark {
            --scrollbar-track-bg: #2d3748;
            --scrollbar-thumb-bg: #718096;
            --scrollbar-thumb-hover-bg: #a0aec0;
        }
        body {
            overflow: hidden;
        }
        #chat-container::-webkit-scrollbar, #canvas-container::-webkit-scrollbar {
            width: 6px;
        }
        #chat-container::-webkit-scrollbar-track, #canvas-container::-webkit-scrollbar-track {
            background: var(--scrollbar-track-bg);
        }
        #chat-container::-webkit-scrollbar-thumb, #canvas-container::-webkit-scrollbar-thumb {
            background: var(--scrollbar-thumb-bg);
            border-radius: 6px;
        }
        #chat-container::-webkit-scrollbar-thumb:hover, #canvas-container::-webkit-scrollbar-thumb:hover {
            background: var(--scrollbar-thumb-hover-bg);
        }
        .message-content pre { background-color: #1e293b; color: #e2e8f0; padding: 1rem; border-radius: 0.5rem; overflow-x: auto; font-family: 'Courier New', Courier, monospace; }
        .dark .message-content pre { background-color: #0f172a; }
        .message-content code:not(pre > code) { background-color: #e2e8f0; color: #1e293b; padding: 0.2em 0.4em; margin: 0; font-size: 85%; border-radius: 3px; }
        .dark .message-content code:not(pre > code) { background-color: #334155; color: #e2e8f0; }
        .message-content h1, .message-content h2, .message-content h3, .message-content h4 { font-weight: 600; margin-top: 1rem; margin-bottom: 0.5rem; }
        .message-content h1 { font-size: 1.5em; }
        .message-content h2 { font-size: 1.25em; }
        .message-content h3 { font-size: 1.1em; }
        .message-content p { margin-bottom: 0.75rem; }
        .message-content ul, .message-content ol { margin-left: 1.25rem; margin-top: 0.5rem; margin-bottom: 1rem; display: block; }
        .message-content ul { list-style-type: disc; }
        .message-content ol { list-style-type: decimal; }
        .message-content li { margin-bottom: 0.5rem; padding-left: 0.5rem; }
        .message-content a { color: #3b82f6; text-decoration: underline; }
        .dark .message-content a { color: #60a5fa; }
        .message-content blockquote { border-left: 4px solid #d1d5db; padding-left: 1rem; margin: 1rem 0; color: #4b5563; font-style: italic; }
        .dark .message-content blockquote { border-left-color: #4b5563; color: #9ca3af; }
        .blinking-cursor { display: inline-block; width: 8px; height: 1.2em; background-color: #333; animation: blink 1s step-end infinite; vertical-align: text-bottom; }
        .dark .blinking-cursor { background-color: #ccc; }
        @keyframes blink { from, to { background-color: transparent; } 50% { background-color: inherit; } }
        #record-btn.recording { animation: pulse-red 1s infinite; background-color: #ef4444; color: white; }
        @keyframes pulse-red { 0% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); transform: scale(1); } 70% { box-shadow: 0 0 0 10px rgba(239, 68, 68, 0); transform: scale(1.05); } 100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); transform: scale(1); } }
        .toast { transition: all 0.4s ease-in-out; opacity: 0; transform: translateX(100%); }
        .toast.show { opacity: 1; transform: translateX(0); }
        .toast.hide { opacity: 0; transform: translateX(120%); }
        #node-context-menu {
            border: 1px solid #e2e8f0;
            background-color: white;
            padding: 0;
        }
        .dark #node-context-menu {
            border: 1px solid #4a5568;
            background-color: #2d3748;
        }
        #node-context-menu button {
            white-space: nowrap;
        }
    </style>
</head>
<body class="bg-gray-100 dark:bg-gray-900 font-sans h-screen flex">

    <!-- Container ch√≠nh c·ªßa ·ª©ng d·ª•ng -->
    <div id="app-container" class="flex flex-1 overflow-hidden">

        <!-- Ph·∫ßn Box Chat (B√™n tr√°i) -->
        <div id="chat-view-container" class="flex flex-col h-full bg-gray-50 dark:bg-slate-900 w-full lg:w-1/3 flex-shrink-0 border-r border-gray-200 dark:border-slate-700">
            <header id="main-header" class="flex-shrink-0 flex justify-between items-center p-3 sm:p-4 bg-white dark:bg-slate-800 border-b border-gray-200 dark:border-slate-700">
                <div class="flex items-center gap-3">
                    <span class="text-2xl">üìö</span>
                    <span class="text-lg font-bold text-gray-800 dark:text-gray-100">AI H·ªçc T·∫≠p</span>
                </div>
                <div class="flex items-center gap-1 sm:gap-2">
                    <!-- N√∫t L∆∞u Phi√™n -->
                    <button id="save-session-btn" class="p-2 rounded-full hover:bg-gray-100 dark:hover:bg-slate-700 transition-colors" title="L∆∞u phi√™n l√†m vi·ªác">
                        <svg class="w-5 h-5 text-gray-600 dark:text-gray-300" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path d="M5 4a2 2 0 012-2h6a2 2 0 012 2v12l-5-3-5 3V4z" /></svg>
                    </button>
                    <!-- N√∫t T·∫£i Phi√™n -->
                    <button id="load-session-btn" class="p-2 rounded-full hover:bg-gray-100 dark:hover:bg-slate-700 transition-colors" title="T·∫£i phi√™n l√†m vi·ªác ƒë√£ l∆∞u">
                        <svg class="w-5 h-5 text-gray-600 dark:text-gray-300" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M2 5a2 2 0 012-2h12a2 2 0 012 2v10a2 2 0 01-2 2H4a2 2 0 01-2-2V5zm3.293 2.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd" /></svg>
                    </button>
                    <!-- N√∫t Phi√™n M·ªõi (thay th·∫ø X√≥a Canvas) -->
                    <button id="new-session-btn" class="p-2 rounded-full hover:bg-gray-100 dark:hover:bg-slate-700 transition-colors" title="B·∫Øt ƒë·∫ßu phi√™n m·ªõi (x√≥a m·ªçi th·ª©)">
                        <svg class="w-5 h-5 text-gray-600 dark:text-gray-300" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm.707-10.293a1 1 0 00-1.414-1.414L6 9.586 4.707 8.293a1 1 0 00-1.414 1.414L7.586 11l-2.293 2.293a1 1 0 001.414 1.414L10 12.414l2.293 2.293a1 1 0 001.414-1.414L11.414 11l2.293-2.293a1 1 0 000-1.414z" clip-rule="evenodd" /></svg>
                    </button>
                    <!-- N√∫t chuy·ªÉn ƒë·ªïi ch·∫ø ƒë·ªô S√°ng/T·ªëi -->
                    <button id="theme-toggle" class="p-2 rounded-full hover:bg-gray-100 dark:hover:bg-slate-700 transition-colors" title="Chuy·ªÉn ch·∫ø ƒë·ªô S√°ng/T·ªëi">
                        <svg id="theme-toggle-dark-icon" class="hidden w-5 h-5 text-gray-600 dark:text-gray-300" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path d="M17.293 13.293A8 8 0 016.707 2.707a8.001 8.001 0 1010.586 10.586z"></path></svg>
                        <svg id="theme-toggle-light-icon" class="hidden w-5 h-5 text-gray-600 dark:text-gray-300" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 2a1 1 0 011 1v1a1 1 0 11-2 0V3a1 1 0 011-1zm4 8a4 4 0 11-8 0 4 4 0 018 0zm-.464 4.95l.707.707a1 1 0 001.414-1.414l-.707-.707a1 1 0 00-1.414 1.414zm2.12-10.607a1 1 0 010 1.414l-.706.707a1 1 0 11-1.414-1.414l.707-.707a1 1 0 011.414 0zM17 11a1 1 0 100-2h-1a1 1 0 100 2h1zm-7 4a1 1 0 011 1v1a1 1 0 11-2 0v-1a1 1 0 011-1zM5.05 14.95a1 1 0 010-1.414l.707-.707a1 1 0 011.414 1.414l-.707.707a1 1 0 01-1.414 0zM3 11a1 1 0 100-2H2a1 1 0 100 2h1z" clip-rule="evenodd"></path></svg>
                    </button>
                </div>
            </header>

            <!-- Khu v·ª±c hi·ªÉn th·ªã tin nh·∫Øn chat -->
            <div id="chat-container" class="flex-1 px-4 pt-4 space-y-4 overflow-y-auto relative">
                 <!-- Tin nh·∫Øn s·∫Ω ƒë∆∞·ª£c ch√®n v√†o ƒë√¢y -->
            </div>

            <!-- V√πng nh·∫≠p li·ªáu chat -->
            <div class="p-4 bg-white dark:bg-slate-800 border-t border-gray-200 dark:border-slate-700">
                <div class="flex items-center gap-3 bg-gray-100 dark:bg-slate-700 rounded-full p-2">
                    <textarea id="prompt-input" rows="1" placeholder="Nh·∫≠p c√¢u h·ªèi ho·∫∑c y√™u c·∫ßu h·ªçc t·∫≠p..." class="flex-1 bg-transparent px-3 py-2 resize-none focus:outline-none dark:text-gray-200 dark:placeholder-gray-400"></textarea>
                    <button id="record-btn" class="p-2 rounded-full hover:bg-gray-200 dark:hover:bg-slate-600 transition-colors" title="Ghi √¢m">
                        <svg class="w-6 h-6 text-gray-600 dark:text-gray-300" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3z"/><path d="M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z"/></svg>
                    </button>
                    <button id="send-btn" class="w-10 h-10 flex items-center justify-center bg-blue-600 rounded-full text-white hover:bg-blue-700 transition-colors disabled:bg-blue-300 dark:disabled:bg-blue-800 disabled:cursor-not-allowed" title="G·ª≠i">
                        <svg class="w-6 h-6" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2 .01 7z"/></svg>
                    </button>
                </div>
            </div>
        </div>

        <!-- Ph·∫ßn Canvas (B√™n ph·∫£i) -->
        <div id="canvas-container" class="flex-1 h-full bg-white dark:bg-gray-800 overflow-auto relative">
            <div id="learning-canvas" class="w-full h-full">
                <div id="canvas-placeholder" class="absolute inset-0 flex items-center justify-center text-gray-400 dark:text-gray-600 text-center p-4">
                    <p class="max-w-md">Ch√†o m·ª´ng b·∫°n ƒë·∫øn v·ªõi AI H·ªçc T·∫≠p! <br> H√£y nh·∫≠p c√¢u h·ªèi, ho·∫∑c <button id="load-from-placeholder-btn" class="text-blue-500 hover:underline">t·∫£i l·∫°i phi√™n l√†m vi·ªác tr∆∞·ªõc</button> n·∫øu c√≥, ƒë·ªÉ b·∫Øt ƒë·∫ßu.</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Container cho th√¥ng b√°o Toast -->
    <div id="toast-container" class="fixed top-5 right-5 z-[100] space-y-2"></div>

    <!-- Custom Context Menu for Nodes -->
    <div id="node-context-menu" class="fixed z-[200] hidden bg-white dark:bg-gray-700 rounded-lg shadow-lg py-2">
        <button id="expand-topic-btn" class="block w-full text-left px-4 py-2 text-gray-800 dark:text-gray-100 hover:bg-gray-100 dark:hover:bg-gray-600">
            M·ªü r·ªông v·∫•n ƒë·ªÅ
        </button>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@2.3.6/dist/purify.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/konva@8.x.x/konva.min.js"></script>
    
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-auth.js";
        import { getAI, getGenerativeModel } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-ai.js";
        
        const firebaseConfig = {
            apiKey: "AIzaSyDDp2ugpgSbqtkQMFLHSNsL0cFMxYBdyng",
            authDomain: "ailearn-e8cc0.firebaseapp.com",
            projectId: "ailearn-e8cc0",
            storageBucket: "ailearn-e8cc0.firebasestorage.app",
            messagingSenderId: "873200516391",
            appId: "1:873200516391:web:1ddc79e4fb45199292fd02"
        };
        
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const ai = getAI(app);
        const model = getGenerativeModel(ai, { model: "gemini-1.5-flash" });

        // Global state variables
        let chatHistory = [];
        let sessionCanvasData = []; // Stores all canvas data objects for the current session
        let isRecording = false;
        let activeSpeech = null;
        let clickedNodeData = null;
        let isCanvasInitialized = false;

        // Cached DOM elements
        const themeToggle = document.getElementById('theme-toggle');
        const themeToggleDarkIcon = document.getElementById('theme-toggle-dark-icon');
        const themeToggleLightIcon = document.getElementById('theme-toggle-light-icon');
        const chatContainer = document.getElementById('chat-container');
        const promptInput = document.getElementById('prompt-input');
        const recordBtn = document.getElementById('record-btn');
        const sendBtn = document.getElementById('send-btn');
        const toastContainer = document.getElementById('toast-container');
        const canvasContainer = document.getElementById('canvas-container');
        const learningCanvas = document.getElementById('learning-canvas');
        const canvasPlaceholder = document.getElementById('canvas-placeholder');
        const loadFromPlaceholderBtn = document.getElementById('load-from-placeholder-btn');
        const newSessionBtn = document.getElementById('new-session-btn');
        const saveSessionBtn = document.getElementById('save-session-btn');
        const loadSessionBtn = document.getElementById('load-session-btn');
        const nodeContextMenu = document.getElementById('node-context-menu');
        const expandTopicBtn = document.getElementById('expand-topic-btn');

        let stage, layer, gridLayer;

        const LEARNING_SYSTEM_PROMPT = `
        B·∫°n l√† m·ªôt gi√°o vi√™n AI chuy√™n nghi·ªáp. M·ª•c ti√™u c·ªßa b·∫°n l√† gi√∫p ng∆∞·ªùi h·ªçc hi·ªÉu s√¢u v·ªÅ m·ªôt ch·ªß ƒë·ªÅ v√† t·∫°o ra c√°c th√†nh ph·∫ßn tr·ª±c quan.
        
        QUY T·∫ÆC CHUNG:
        1.  **Ph√¢n t√≠ch & Chia nh·ªè:** Chia ch·ªß ƒë·ªÅ th√†nh c√°c ph·∫ßn logic, c√≥ c·∫•u tr√∫c ph√¢n c·∫•p.
        2.  **Gi·∫£i th√≠ch Chatbox:** Cung c·∫•p gi·∫£i th√≠ch chi ti·∫øt, r√µ r√†ng b·∫±ng Markdown.
        3.  **D·ªØ li·ªáu Canvas (QUAN TR·ªåNG):** Lu√¥n t·∫°o m·ªôt ƒë·ªëi t∆∞·ª£ng JSON ƒë·ªÉ v·∫Ω l√™n Canvas. JSON ph·∫£i n·∫±m trong kh·ªëi code \`\`\`json.
            - Ph√¢n b·ªï c√°c node m·ªôt c√°ch c√≥ t·ªï ch·ª©c tr√™n canvas (gi·∫£ ƒë·ªãnh k√≠ch th∆∞·ªõc 800x600).
            - Node ƒë·∫ßu ti√™n trong m·∫£ng 'nodes' ph·∫£i l√† node ch·ªß ƒë·ªÅ ch√≠nh, ƒë√°nh d·∫•u b·∫±ng "isMainTopic": true.
            - M·ªói node ph·∫£i c√≥ "description" ƒë·∫ßy ƒë·ªß.
        
        QUY T·∫ÆC X·ª¨ L√ù Y√äU C·∫¶U:

        A. N·∫æU Y√äU C·∫¶U L√Ä M·ªòT CH·ª¶ ƒê·ªÄ M·ªöI (v√≠ d·ª•: "gi·∫£i th√≠ch quang h·ª£p"):
           - H√£y t·∫°o m·ªôt b√†i h·ªçc ho√†n ch·ªânh t·ª´ ƒë·∫ßu.
           - JSON c·ªßa b·∫°n ph·∫£i ch·ª©a ƒë·∫ßy ƒë·ªß c√°c node v√† k·∫øt n·ªëi cho to√†n b·ªô ch·ªß ƒë·ªÅ.
           - V√≠ d·ª• JSON cho ch·ªß ƒë·ªÅ m·ªõi:
             \`\`\`json
             {
               "type": "lesson_data",
               "title": "Ch·ªß ƒê·ªÅ M·ªõi",
               "nodes": [
                 { "id": "node1", "type": "concept", "text": "Kh√°i ni·ªám ch√≠nh", "description": "...", "x": 100, "y": 100, "color": "#FFDDC1", "isMainTopic": true },
                 { "id": "node2", "type": "detail", "text": "Chi ti·∫øt 1", "description": "...", "x": 300, "y": 150, "color": "#C1FFDD" }
               ],
               "connections": [ { "from": "node1", "to": "node2" } ]
             }
             \`\`\`

        B. N·∫æU Y√äU C·∫¶U B·∫ÆT ƒê·∫¶U B·∫∞NG "ExpandTopic:", (v√≠ d·ª•: "ExpandTopic: node2 - Chi ti·∫øt 1"):
           - ƒê√¢y l√† y√™u c·∫ßu m·ªü r·ªông m·ªôt node ƒê√É C√ì tr√™n canvas.
           - **CH·ªà t·∫°o ra c√°c node v√† k·∫øt n·ªëi M·ªöI** li√™n quan ƒë·∫øn node cha ƒë√≥.
           - **KH√îNG ƒë∆∞·ª£c t·∫°o l·∫°i c√°c node ƒë√£ c√≥.**
           - C√°c k·∫øt n·ªëi m·ªõi ph·∫£i xu·∫•t ph√°t t·ª´ node cha (v√≠ d·ª•: "from": "node2").
           - V√≠ d·ª• JSON cho y√™u c·∫ßu m·ªü r·ªông:
             \`\`\`json
             {
               "type": "lesson_expansion",
               "title": "M·ªü r·ªông: Chi ti·∫øt 1",
               "nodes": [
                 { "id": "node2_sub1", "type": "example", "text": "V√≠ d·ª• cho Chi ti·∫øt 1", "description": "...", "x": 450, "y": 100, "color": "#DDA0DD" },
                 { "id": "node2_sub2", "type": "sub-concept", "text": "Kh√°i ni·ªám con", "description": "...", "x": 450, "y": 200, "color": "#DDA0DD" }
               ],
               "connections": [
                 { "from": "node2", "to": "node2_sub1" },
                 { "from": "node2", "to": "node2_sub2" }
               ]
             }
             \`\`\`
        `;

        // --- H√ÄM TI·ªÜN √çCH ---
        function showToast(message, type = 'info') {
            const toast = document.createElement('div');
            let bgColor, textColor, icon;
            switch (type) {
                case 'success':
                    bgColor = 'bg-green-100 dark:bg-green-900'; textColor = 'text-green-700 dark:text-green-200';
                    icon = `<svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path></svg>`;
                    break;
                case 'error':
                    bgColor = 'bg-red-100 dark:bg-red-900'; textColor = 'text-red-700 dark:text-red-200';
                    icon = `<svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd"></path></svg>`;
                    break;
                default:
                    bgColor = 'bg-blue-100 dark:bg-blue-900'; textColor = 'text-blue-700 dark:text-blue-200';
                    icon = `<svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd"></path></svg>`;
                    break;
            }
            toast.className = `toast max-w-xs w-full ${bgColor} ${textColor} p-4 rounded-lg shadow-lg flex items-center space-x-3`;
            toast.innerHTML = `<div class="flex-shrink-0">${icon}</div><div class="flex-1 text-sm font-medium">${message}</div>`;
            toastContainer.appendChild(toast);
            requestAnimationFrame(() => toast.classList.add('show'));
            const hideToast = () => {
                toast.classList.remove('show');
                toast.classList.add('hide');
                toast.addEventListener('transitionend', () => toast.remove(), { once: true });
            };
            toast.addEventListener('click', hideToast);
            setTimeout(hideToast, 4000);
        }

        function copyToClipboard(text) {
            const textarea = document.createElement('textarea');
            textarea.value = text;
            document.body.appendChild(textarea);
            textarea.select();
            try {
                document.execCommand('copy');
                showToast('ƒê√£ sao ch√©p!', 'success');
            } catch (err) {
                showToast('Kh√¥ng th·ªÉ sao ch√©p.', 'error');
            }
            document.body.removeChild(textarea);
        }

        // --- QU·∫¢N L√ù PHI√äN ---
        function saveSession() {
            if (chatHistory.length === 0 && sessionCanvasData.length === 0) {
                showToast("Kh√¥ng c√≥ g√¨ ƒë·ªÉ l∆∞u.", "info");
                return;
            }
            const session = {
                chatHistory: chatHistory,
                canvasData: sessionCanvasData,
                timestamp: new Date().toISOString()
            };
            localStorage.setItem('aiLearningSession', JSON.stringify(session));
            showToast("ƒê√£ l∆∞u phi√™n l√†m vi·ªác!", "success");
        }

        function loadSession() {
            const savedSessionJSON = localStorage.getItem('aiLearningSession');
            if (!savedSessionJSON) {
                showToast("Kh√¥ng t√¨m th·∫•y phi√™n ƒë√£ l∆∞u.", "info");
                return;
            }
            const savedSession = JSON.parse(savedSessionJSON);
            
            newSession(false); // Clear current state without showing toast

            chatHistory = savedSession.chatHistory || [];
            sessionCanvasData = savedSession.canvasData || [];

            // Re-render chat
            chatHistory.forEach(msg => {
                addMessage(msg.role, msg.parts[0].text, false);
            });
            chatContainer.scrollTop = chatContainer.scrollHeight;

            // Re-render canvas if it's ready
            if (isCanvasInitialized) {
                renderFullCanvasFromSession();
            }
            
            showToast("ƒê√£ t·∫£i phi√™n l√†m vi·ªác!", "success");
        }

        function newSession(showToastMsg = true) {
            chatHistory = [];
            sessionCanvasData = [];
            chatContainer.innerHTML = '';
            if (layer) {
                layer.destroyChildren();
                layer.batchDraw();
            }
            canvasPlaceholder.classList.remove('hidden');
            if (showToastMsg) {
                showToast("B·∫Øt ƒë·∫ßu phi√™n l√†m vi·ªác m·ªõi.", "info");
            }
        }

        // --- X√ÅC TH·ª∞C & KH·ªûI T·∫†O ---
        onAuthStateChanged(auth, async user => {
            if (user) {
                // FIX: Use ResizeObserver to robustly initialize and resize the canvas
                const resizeObserver = new ResizeObserver(entries => {
                    for (let entry of entries) {
                        // Use contentRect for accurate dimensions
                        const { width, height } = entry.contentRect;
                        if (width > 0 && height > 0) {
                            initOrUpdateCanvas(width, height);
                        }
                    }
                });
                resizeObserver.observe(canvasContainer);

                // Load session data. The observer will trigger the first render when the canvas is ready.
                const savedSessionJSON = localStorage.getItem('aiLearningSession');
                if (savedSessionJSON) {
                    loadSession(); // This will populate data; render is handled by the observer callback
                } else {
                    addMessage('ai', 'Ch√†o m·ª´ng! H√£y b·∫Øt ƒë·∫ßu b·∫±ng c√°ch h·ªèi m·ªôt ch·ªß ƒë·ªÅ.');
                }
            } else {
                try {
                    await signInAnonymously(auth);
                } catch (error) {
                    console.error("L·ªói ƒëƒÉng nh·∫≠p ·∫©n danh:", error);
                    showToast("L·ªói k·∫øt n·ªëi. Vui l√≤ng t·∫£i l·∫°i trang.", "error");
                }
            }
        });

        // --- CH·∫æ ƒê·ªò S√ÅNG/T·ªêI ---
        const updateThemeIcon = () => {
            if (document.documentElement.classList.contains('dark')) {
                themeToggleDarkIcon.classList.add('hidden');
                themeToggleLightIcon.classList.remove('hidden');
            } else {
                themeToggleDarkIcon.classList.remove('hidden');
                themeToggleLightIcon.classList.add('hidden');
            }
        };
        themeToggle.addEventListener('click', () => {
            document.documentElement.classList.toggle('dark');
            localStorage.setItem('theme', document.documentElement.classList.contains('dark') ? 'dark' : 'light');
            updateThemeIcon();
            if (gridLayer) drawGrid(); // Redraw grid with new theme color
        });
        if (localStorage.getItem('theme') === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
            document.documentElement.classList.add('dark');
        } else {
            document.documentElement.classList.remove('dark');
        }
        updateThemeIcon();

        // --- LOGIC CHAT ---
        function addMessageActions(actionsContainer, rawText) {
            if (!actionsContainer || !rawText || rawText.includes('blinking-cursor')) return;
            actionsContainer.innerHTML = '';
            const copyBtn = document.createElement('button');
            copyBtn.className = 'p-1.5 text-gray-500 dark:text-gray-400 hover:text-blue-600 dark:hover:text-blue-400 rounded-full';
            copyBtn.innerHTML = `<svg class="w-4 h-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 17.25v3.375c0 .621-.504 1.125-1.125 1.125h-9.75a1.125 1.125 0 0 1-1.125-1.125V7.875c0-.621.504-1.125 1.125-1.125H6.75a9.06 9.06 0 0 1 1.5.124m7.5 10.376h3.375c.621 0 1.125-.504 1.125-1.125V11.25c0-4.46-3.243-8.161-7.5-8.876a9.06 9.06 0 0 0-1.5-.124H9.375c-.621 0-1.125.504-1.125 1.125v3.5m7.5 10.375H9.375a1.125 1.125 0 0 1-1.125-1.125v-9.25m12 6.625v-1.875a3.375 3.375 0 00-3.375-3.375h-1.5a1.125 1.125 0 01-1.125-1.125v-1.5a3.375 3.375 0 00-3.375-3.375H9.75" /></svg>`;
            copyBtn.title = 'Sao ch√©p';
            copyBtn.onclick = () => copyToClipboard(rawText);
            actionsContainer.appendChild(copyBtn);
        }

        function addMessage(role, text, shouldScroll = true) {
            const messageWrapper = document.createElement('div');
            let contentElem, statusElem, actionsContainer = null;

            if (role === 'ai' || role === 'model') {
                messageWrapper.className = 'w-full space-y-2';
                messageWrapper.innerHTML = `<div class="flex items-center justify-between"><div class="flex items-center gap-2"><div class="w-7 h-7 rounded-full flex-shrink-0 bg-gradient-to-tr from-purple-400 to-indigo-500 flex items-center justify-center"><svg class="w-4 h-4 text-white" xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px" fill="currentColor"><path d="M12 6c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6 2.69-6 6-6m0-2c-4.42 0-8 3.58-8 8s3.58 8 8 8 8-3.58 8-8-3.58-8-8-8z"/><path d="M12 10c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"/></svg></div><span class="font-semibold text-gray-800 dark:text-gray-200">AI H·ªçc T·∫≠p</span></div><div class="ai-status text-xs text-gray-500"></div></div><div class="message-content text-gray-800 dark:text-gray-200"></div><div class="message-actions mt-1 flex justify-end items-center gap-2"></div>`;
                contentElem = messageWrapper.querySelector('.message-content');
                statusElem = messageWrapper.querySelector('.ai-status');
                actionsContainer = messageWrapper.querySelector('.message-actions');
            } else { // user
                messageWrapper.className = 'flex justify-end';
                messageWrapper.innerHTML = `<div class="message-content px-4 py-2 rounded-2xl bg-blue-600 dark:bg-blue-700 text-white max-w-xs sm:max-w-md lg:max-w-2xl"></div>`;
                contentElem = messageWrapper.querySelector('.message-content');
            }
            
            contentElem.innerHTML = DOMPurify.sanitize(marked.parse(text));
            chatContainer.appendChild(messageWrapper);
            if (shouldScroll) chatContainer.scrollTop = chatContainer.scrollHeight;
            return { messageWrapper, contentElem, statusElem, actionsContainer };
        }
        
        async function sendMessage() {
            const promptText = promptInput.value.trim();
            if (!promptText) return;

            const isExpansion = promptText.startsWith("ExpandTopic:");
            if (isExpansion) {
                const topicName = promptText.split(" - ")[1] || "ch·ªß ƒë·ªÅ";
                addMessage('user', `(M·ªü r·ªông v·ªÅ: ${topicName})`);
            } else {
                sessionCanvasData = [];
                addMessage('user', promptText);
            }

            promptInput.value = '';
            adjustInputHeight();
            sendBtn.disabled = true;
            canvasPlaceholder.classList.add('hidden');

            chatHistory.push({ role: 'user', parts: [{ text: promptText }] });

            const { contentElem, statusElem, actionsContainer } = addMessage('ai', '<span class="blinking-cursor"></span>');
            if (statusElem) statusElem.textContent = 'ƒêang nghƒ©...';

            try {
                const historyForApiModel = chatHistory.map(msg => ({ role: msg.role, parts: msg.parts }));
                const chatSession = model.startChat({ history: historyForApiModel.slice(0, -1) });
                const result = await chatSession.sendMessageStream(LEARNING_SYSTEM_PROMPT + "\nUser request: " + promptText);

                let fullResponseText = "";
                if (statusElem) statusElem.textContent = 'ƒêang vi·∫øt...';

                for await (const chunk of result.stream) {
                    fullResponseText += chunk.text();
                    const markdownPartForDisplay = fullResponseText.split('```json')[0];
                    contentElem.innerHTML = DOMPurify.sanitize(marked.parse(markdownPartForDisplay + '<span class="blinking-cursor"></span>'));
                    chatContainer.scrollTop = chatContainer.scrollHeight;
                }
                
                if (statusElem) statusElem.classList.add('hidden');
                
                const finalMarkdownPart = fullResponseText.split('```json')[0].trim();
                contentElem.innerHTML = DOMPurify.sanitize(marked.parse(finalMarkdownPart));
                addMessageActions(actionsContainer, finalMarkdownPart);

                chatHistory.push({ role: 'model', parts: [{ text: fullResponseText }] });

                const jsonStringMatch = fullResponseText.match(/```json\n([\s\S]*?)\n```/);
                if (jsonStringMatch && jsonStringMatch[1]) {
                    try {
                        const newCanvasData = JSON.parse(jsonStringMatch[1]);
                        sessionCanvasData.push(newCanvasData);
                        renderFullCanvasFromSession();
                    } catch (e) {
                        console.error("L·ªói ph√¢n t√≠ch JSON:", e);
                        showToast("AI tr·∫£ v·ªÅ d·ªØ li·ªáu canvas kh√¥ng h·ª£p l·ªá.", "error");
                    }
                }

            } catch (error) {
                console.error("L·ªói sendMessage:", error);
                contentElem.innerHTML = `**L·ªói:** ${error.message}`;
                showToast(`L·ªói g·ª≠i tin nh·∫Øn: ${error.message}`, 'error');
            } finally {
                sendBtn.disabled = false;
            }
        }

        function adjustInputHeight() {
            promptInput.style.height = 'auto';
            promptInput.style.height = promptInput.scrollHeight + 'px';
        }
        
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        if(SpeechRecognition) {
            const recognition = new SpeechRecognition();
            recognition.continuous = false; recognition.lang = 'vi-VN'; recognition.interimResults = false;
            recognition.onstart = () => { isRecording = true; recordBtn.classList.add('recording'); promptInput.placeholder = 'ƒêang nghe...'; };
            recognition.onend = () => { isRecording = false; recordBtn.classList.remove('recording'); promptInput.placeholder = 'Nh·∫≠p c√¢u h·ªèi...'; };
            recognition.onresult = (event) => { promptInput.value = event.results[event.results.length - 1][0].transcript.trim(); adjustInputHeight(); sendMessage(); };
            recognition.onerror = (event) => { showToast(`L·ªói ghi √¢m: ${event.error}`, 'error'); };
            recordBtn.addEventListener('click', () => { isRecording ? recognition.stop() : recognition.start(); });
        } else { 
            recordBtn.classList.add('hidden');
        }
        
        // --- LOGIC CANVAS (Konva.js) ---
        function initOrUpdateCanvas(width, height) {
            if (!stage) {
                // First time initialization
                stage = new Konva.Stage({
                    container: 'learning-canvas',
                    width: width,
                    height: height,
                });
                gridLayer = new Konva.Layer();
                layer = new Konva.Layer();
                stage.add(gridLayer, layer);
                
                // Add event listeners only once
                stage.content.oncontextmenu = (e) => e.preventDefault();
                stage.on('click', (e) => { if (e.target === stage || e.target === gridLayer) hideNodeContextMenu(); });
                window.addEventListener('scroll', hideNodeContextMenu, true);
                const scaleBy = 1.1;
                stage.on('wheel', (e) => {
                    e.evt.preventDefault();
                    const oldScale = stage.scaleX();
                    const pointer = stage.getPointerPosition();
                    const mousePointTo = { x: (pointer.x - stage.x()) / oldScale, y: (pointer.y - stage.y()) / oldScale, };
                    const newScale = e.evt.deltaY < 0 ? oldScale * scaleBy : oldScale / scaleBy;
                    stage.scale({ x: newScale, y: newScale });
                    const newPos = { x: pointer.x - mousePointTo.x * newScale, y: pointer.y - mousePointTo.y * newScale, };
                    stage.position(newPos);
                });
                stage.draggable(true);
                
                isCanvasInitialized = true;
                console.log(`Canvas initialized with size: ${width}x${height}`);

                // After initializing, try to render any loaded data
                if (sessionCanvasData.length > 0) {
                    renderFullCanvasFromSession();
                }
            } else {
                // Just update size on resize
                stage.width(width);
                stage.height(height);
            }
            drawGrid();
        }

        function drawGrid() {
            if (!stage) return;
            gridLayer.destroyChildren();
            const gridSize = 50;
            const stageWidth = stage.width() / stage.scaleX() + 100;
            const stageHeight = stage.height() / stage.scaleY() + 100;
            const strokeColor = document.documentElement.classList.contains('dark') ? '#4a5568' : '#e2e8f0';
            for (let i = 0; i * gridSize < stageWidth; i++) {
                gridLayer.add(new Konva.Line({ points: [i * gridSize, 0, i * gridSize, stageHeight], stroke: strokeColor, strokeWidth: 0.5, listening: false }));
            }
            for (let i = 0; i * gridSize < stageHeight; i++) {
                gridLayer.add(new Konva.Line({ points: [0, i * gridSize, stageWidth, i * gridSize], stroke: strokeColor, strokeWidth: 0.5, listening: false }));
            }
        }

        function getLineRectIntersection(p1, p2, rect) {
            const { x, y, width, height } = rect;
            const min = { x: x, y: y };
            const max = { x: x + width, y: y + height };
            const d = { x: p2.x - p1.x, y: p2.y - p1.y };
            let tmin = 0.0;
            let tmax = 1.0;

            for (const axis of ['x', 'y']) {
                if (Math.abs(d[axis]) < 1e-6) {
                    if (p1[axis] < min[axis] || p1[axis] > max[axis]) return null;
                } else {
                    const ood = 1.0 / d[axis];
                    let t1 = (min[axis] - p1[axis]) * ood;
                    let t2 = (max[axis] - p1[axis]) * ood;
                    if (t1 > t2) [t1, t2] = [t2, t1];
                    tmin = Math.max(tmin, t1);
                    tmax = Math.min(tmax, t2);
                    if (tmin > tmax) return null;
                }
            }
            return { x: p1.x + d.x * tmin, y: p1.y + d.y * tmin };
        }

        function updateLinksForNode(movedNodeGroup) {
            const movedNodeId = movedNodeGroup.getAttr('nodeId');
            layer.find('Arrow').forEach(arrow => {
                const sourceId = arrow.getAttr('sourceNodeId');
                const targetId = arrow.getAttr('targetNodeId');
                if (sourceId === movedNodeId || targetId === movedNodeId) {
                    const sourceNodeGroup = layer.findOne(`#${sourceId}`);
                    const targetNodeGroup = layer.findOne(`#${targetId}`);
                    if (!sourceNodeGroup || !targetNodeGroup) return;

                    const sourceRectShape = sourceNodeGroup.findOne('Rect');
                    const targetRectShape = targetNodeGroup.findOne('Rect');
                    if (!sourceRectShape || !targetRectShape) return;

                    const sourceRect = sourceNodeGroup.getClientRect();
                    const targetRect = targetNodeGroup.getClientRect();

                    const p1 = { x: sourceRect.x + sourceRect.width / 2, y: sourceRect.y + sourceRect.height / 2 };
                    const p2 = { x: targetRect.x + targetRect.width / 2, y: targetRect.y + targetRect.height / 2 };
                    
                    const start = getLineRectIntersection(p2, p1, sourceRect);
                    const end = getLineRectIntersection(p1, p2, targetRect);
                    
                    if (start && end) {
                        arrow.points([start.x, start.y, end.x, end.y]);
                    }
                }
            });
        }

        function showNodeContextMenu(x, y) {
            nodeContextMenu.style.left = `${x}px`;
            nodeContextMenu.style.top = `${y}px`;
            nodeContextMenu.classList.remove('hidden');
        }

        function hideNodeContextMenu() {
            nodeContextMenu.classList.add('hidden');
            clickedNodeData = null;
        }
        
        function renderFullCanvasFromSession() {
            if (!isCanvasInitialized) {
                console.warn("Canvas not ready, render call deferred.");
                return;
            }
            layer.destroyChildren();
            canvasPlaceholder.classList.add('hidden');

            const masterData = { nodes: [], connections: [] };
            const nodeIds = new Set();
            sessionCanvasData.forEach(dataPart => {
                if (dataPart.nodes) {
                    dataPart.nodes.forEach(node => {
                        if (!nodeIds.has(node.id)) {
                            masterData.nodes.push(node);
                            nodeIds.add(node.id);
                        }
                    });
                }
                if (dataPart.connections) {
                    masterData.connections.push(...dataPart.connections);
                }
            });

            if (masterData.nodes.length === 0) {
                canvasPlaceholder.classList.remove('hidden');
                return;
            }

            const PADDING = 20;
            const nodesMap = new Map();

            masterData.nodes.forEach(nodeData => {
                const group = new Konva.Group({ x: nodeData.x, y: nodeData.y, draggable: true, id: nodeData.id, nodeId: nodeData.id });
                const text = new Konva.Text({ text: nodeData.text, fontSize: 16, fontFamily: 'Inter, sans-serif', fill: '#333', padding: PADDING / 2, wrap: 'word' });
                const textMetrics = text.measureSize(nodeData.text);
                const rectWidth = Math.max(120, textMetrics.width + PADDING); 
                const rectHeight = Math.max(60, textMetrics.height + PADDING);
                const rect = new Konva.Rect({ width: rectWidth, height: rectHeight, fill: nodeData.color || '#E0E0E0', cornerRadius: 10, shadowBlur: 5, shadowOpacity: 0.2, stroke: '#AAAAAA', strokeWidth: 1 });
                if (nodeData.isMainTopic) { rect.stroke("#FF0000"); rect.strokeWidth(3); }
                text.position({ x: 0, y: (rectHeight - textMetrics.height) / 2 });
                text.width(rectWidth);
                text.align('center');

                group.add(rect, text);
                layer.add(group);
                nodesMap.set(nodeData.id, group);

                group.on('click', (e) => {
                    if (e.evt.button === 0) {
                        e.cancelBubble = true; 
                        addMessage('ai', `**Chi ti·∫øt cho "${nodeData.text}":**\n\n${nodeData.description || 'Kh√¥ng c√≥ m√¥ t·∫£.'}`);
                    }
                });
                group.on('contextmenu', (e) => {
                    e.evt.preventDefault(); e.cancelBubble = true;
                    clickedNodeData = nodeData;
                    showNodeContextMenu(e.evt.clientX, e.evt.clientY);
                });
                group.on('dragmove', () => updateLinksForNode(group));
            });

            masterData.connections.forEach(conn => {
                const sourceNode = nodesMap.get(conn.from);
                const targetNode = nodesMap.get(conn.to);
                if (sourceNode && targetNode) {
                    const arrow = new Konva.Arrow({ stroke: '#000', strokeWidth: 2, pointerLength: 10, pointerWidth: 10, sourceNodeId: conn.from, targetNodeId: conn.to });
                    layer.add(arrow);
                }
            });

            layer.find('Group').forEach(group => updateLinksForNode(group));
            layer.batchDraw();
        }

        // --- GLOBAL EVENT LISTENERS ---
        sendBtn.addEventListener('click', sendMessage);
        promptInput.addEventListener('keydown', e => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendMessage(); } });
        promptInput.addEventListener('input', adjustInputHeight);
        
        newSessionBtn.addEventListener('click', () => newSession());
        saveSessionBtn.addEventListener('click', saveSession);
        loadSessionBtn.addEventListener('click', loadSession);
        loadFromPlaceholderBtn.addEventListener('click', loadSession);

        expandTopicBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            hideNodeContextMenu();
            if (clickedNodeData) {
                const promptToAI = `ExpandTopic: ${clickedNodeData.id} - ${clickedNodeData.text}`;
                promptInput.value = promptToAI;
                sendMessage();
            }
        });
        nodeContextMenu.addEventListener('click', e => e.stopPropagation());

    </script>
</body>
</html>
